# choosing shards

- documents 는 특정 shard 에 해시되어 있다.
- 클러스터 안에 있는 각각의 머신에 한 개나 그 이상의 샤드를 넣을 수 있다. 
- 이건 클러스터의 각 노드에 얼마만큼의 RAM 을 사용할 수 있는지와 몇 개의 샤드를 넣을 수 있는지에 따라 달라진다.
- 모든 샤드는 그것 자체의 lucene 색인을 포함한다. 그래서 각 샤드와 관련해 일정 양의 overhead 가 발생한다.

# primary and replica shards

- 색인에 필요한 적절한 프라이머리와 레플리카 샤드 수를 지정해야 함.
	- 레플리카의 수는 각 프라이머리 샤드에 적용됨.
- 하나의 노드가 다운될지라도 장애 방지 falut tolerance 
- 읽기 능력도 늘어남.
- 검색을 제공하거나 쓰는 것보다 읽는 게 많은 비즈니스를 운영한다면 많은 프라이머리 샤드가 필요하지 않다. 읽기 요청이 늘어난다고 해도 다시 인덱싱 하는 것도 아니고, 필요한 만큼 새로운 레플리카를 추가하면 된다.
- 그러나, 엄청난 양의 로그 데이터를 수집하는 일을 계속해서 반복해야 한다면 적절한 프라이머리 샤드 수를 고려해야 한다.
- 쓰기 요청은 프라이머리 샤드로 연결되고, 이를 복제한다. 그러니 주어진 시간에 쓰기 요청을 감당할 수 있게 충분한 프라이머리 샤드를 보유해야 한다.

# how many shards ?

- 재색인 없이는 후에 프라이머리 샤드를 추가할 수 없다.
	- cf. 색인을 복사해서 프라이머리 샤드를 더 넣고 다시 인덱싱할 순 있음. 그리고 그 새 색인을  application 에 불러 덮어씌우는 방법
- 재색인 없이 레플리카 샤드를 쉽게 추가할 수 있다.
		- read heavy 한 애플리케이션일 때, 레플리카 샤드를 추가하기.
		- 인덱싱 없이도 런타임에 처리 할 수 있다.
- 샤드에 따른 비용도 들고, Lucene 과 관련해 이미 정해진 overhead가 있기에 1000개의 샤드를 만들어서 하나의 노드에 붙이기도 어렵다.
- 이미 존재하는 하드웨어가 한계에 다다랐는데 거기에 샤드를 추가하는 건 그다지 좋지 않다.

- 응용 프로그램에 있는 데이터의 성질에 달려있다.
	- 읽기와 쓰기 요청의 균형, 스키마의 복잡성, 어떻게 색인되어 있고, 매핑, 분석 되어 있는지

- 무작정 과하게 할당하기 보다는, 단계적으로 확장하는 것이 좋다.
- 실험해볼 수 밖에 없다. 먼저, 하나의 서버로 레플리카 없이, 하나의 샤드만 이용해서 문서를 채우고 쿼리를 날려보자. 생성 트래픽을 시뮬레이션하는 도구나 스크립트를 통해서 실험 해보기. 무너질 때까지 해보면 샤드 하나의 읽기와 쓰기 용량이 얼마나 되는지, 실제 생성 트래픽을 감당하려면 몇 개의 샤드가 필요한지 추정할 수 있다.
- 쓰기와 읽기 트래픽을 위한 현재 요구 사항, 또 추후 추정되는 확장 시(근 몇 년 정도,,)의 요구 사항까지 생각해 샤드 수를 실험하면 정해야 한다.

# create a new index

- 샤드의 수를 10으로 지정하고, 레플리카를 1로 지정하면 10개의 프라이머리 샤드와 10개의 레플리카 샤드를 얻게 됨.
~~~
PUT /new_index
{
	"settings" : {
		"number_of_shards": 10,
		"number_of_relicas": 1
	}
}
~~~


### index templates
- 항상 색인의 셋팅을 저장해두고, 또 할 때 이전에 했던 것을 보는 것이 좋다. 이를 위해 index templates 를 생성해둬야 한다. 
- 새 색인에 매핑, 애널라이저, 세팅 등 자동으로 적용해줌.